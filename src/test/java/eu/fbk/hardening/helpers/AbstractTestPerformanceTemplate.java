package eu.fbk.hardening.helpers;

import eu.fbk.hardening.annotation.Obfuscation;
import eu.fbk.hardening.annotation.Protections;
import eu.fbk.hardening.support.NativeCompiler;
import org.jetbrains.annotations.NotNull;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.*;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;


/**
 * Template used to test the performance of the transformed (obfuscated) method.
 * A certain pattern is executed multiple times inside a function and the time is taken before and after its execution.
 * Two files are generated by this class: one that will be executed in plain java and one that will be executed by the
 * C transformed code.
 * This class will generate a csv report with the same name of getTestClass() containing for each row the execution time
 * in Java and C respectively. Only the repeated pattern is considered.
 * <p>
 * Check the documentation for information about methods and how to specify the number of repetitions or the pattern.
 *
 * @author D.Pizzolotto
 */
public abstract class AbstractTestPerformanceTemplate extends Java2CTests {

    /**
     * Checks the time required to run a set of opcodes
     */
    @Test
    public void testPerformance() {

        //write the .class file
        try {
            emitter(true);
            emitter(false);
        } catch (IOException e) {
            Assertions.fail(e.getMessage());
            e.printStackTrace();
        }

        String libname = this.getClass().getPackage().getName() + "." + getClassName();
        String name = libname.replaceAll("\\.", "/") + ".class";
        //transform it
        transformJava2C(name, libname, getCPerformanceDir());

        try {
            //profile the generated .c file
            profileFile(libname);
        } catch (IOException e) {
            Assertions.fail("Profilation impossible");
            e.printStackTrace();
        }

        //compile it by setting ad-hoc flags
        NativeCompiler compiler = new NativeCompiler();
        compiler.overrideFlags("-fauto-inc-dec " +
                "-fbranch-count-reg " +
                "-fcombine-stack-adjustments " +
                "-fcompare-elim " +
                "-fcprop-registers " +
                "-fdefer-pop " +
                "-fdelayed-branch " +
                "-fforward-propagate " +
                "-fguess-branch-probability " +
                "-fif-conversion " +
                "-fif-conversion2 " +
                "-finline-functions-called-once " +
                "-fipa-profile " +
                "-fipa-pure-const " +
                "-fipa-reference " +
                "-fmerge-constants " +
                "-fmove-loop-invariants " +
                "-fomit-frame-pointer " +
                "-freorder-blocks " +
                "-fshrink-wrap " +
                "-fshrink-wrap-separate " +
                "-fsplit-wide-types " +
                "-fssa-backprop " +
                "-fssa-phiopt " +
                "-ftree-bit-ccp " +
                "-ftree-ccp " +
                "-ftree-ch " +
                "-ftree-coalesce-vars " +
                "-ftree-copy-prop " +
                "-ftree-dominator-opts " +
                "-ftree-forwprop " +
                "-ftree-fre " +
                "-ftree-phiprop " +
                "-ftree-pta " +
                "-ftree-scev-cprop " +
                "-ftree-sink " +
                "-ftree-slsr " +
                "-ftree-sra " +
                "-ftree-ter " +
                "-funit-at-a-time " +
                //O2
                "-falign-functions " +
                "-falign-jumps " +
                "-falign-labels " +
                "-falign-loops " +
                "-fcaller-saves " +
                "-fcode-hoisting " +
                "-fcrossjumping " +
                "-fcse-follow-jumps " +
                "-fcse-skip-blocks " +
                "-fdelete-null-pointer-checks " +
                "-fdevirtualize " +
                "-fdevirtualize-speculatively " +
                "-fexpensive-optimizations " +
                "-fhoist-adjacent-loads " +
                "-finline-small-functions " +
                "-findirect-inlining " +
                "-fipa-bit-cp  " +
                "-fipa-cp " +
                "-fipa-icf " +
                "-fipa-ra " +
                "-fipa-sra " +
                "-fipa-vrp " +
                "-fisolate-erroneous-paths-dereference " +
                "-flra-remat " +
                "-foptimize-sibling-calls " +
                "-foptimize-strlen " +
                "-fpartial-inlining " +
                "-fpeephole2 " +
                "-freorder-blocks-algorithm=stc " +
                "-freorder-blocks-and-partition  " +
                "-freorder-functions " +
                "-frerun-cse-after-loop  " +
                "-fschedule-insns  " +
                "-fschedule-insns2 " +
                "-fsched-interblock  " +
                "-fsched-spec " +
                "-fstore-merging " +
                "-fstrict-aliasing " +
                "-fthread-jumps " +
                "-ftree-builtin-call-dce " +
                "-ftree-pre " +
                "-ftree-switch-conversion  " +
                "-ftree-tail-merge " +
                "-ftree-vrp " +
                //O3
                "-finline-functions " +
                "-fipa-cp-clone " +
                "-floop-interchange " +
                "-floop-unroll-and-jam " +
                "-fpeel-loops " +
                "-fpredictive-commoning " +
                "-fsplit-paths " +
                "-ftree-loop-distribute-patterns " +
                "-ftree-loop-distribution " +
                "-ftree-loop-vectorize " +
                "-ftree-partial-pre " +
                "-ftree-slp-vectorize " +
                "-funswitch-loops " +
                "-fvect-cost-model ");
        buildJava2C(libname, compiler);

        //load it and run it n times
        try {
            ArrayList<Double> resultsJava = new ArrayList<>(executionRepetitions());
            ArrayList<Double> resultsC = new ArrayList<>(executionRepetitions());
            Class clazzJava = TestUtils.loadClass(getJavaPerformanceDir(), this.getClass().getPackage().getName() + "." + getClassName());
            Class clazzC = TestUtils.loadClass(getCPerformanceDir(), this.getClass().getPackage().getName() + "." + getClassName());
            Object targetJava = clazzJava.newInstance();
            Object targetC = clazzC.newInstance();
            for (int i = 0; i < executionRepetitions(); i++) {
                Object resJava = TestUtils.runCode(targetJava, getTestMethodName(), getTestMethodParams(), getTestMethodParams())[0];
                Object resC = TestUtils.runCode(targetC, getTestMethodName(), getTestMethodParams(), getTestMethodParams())[0];
                if (resJava instanceof Double) {
                    double timeJava = (Double) resJava;
                    resultsJava.add(timeJava);
                } else
                    Assertions.fail("Unexpected return value: " + resJava.getClass());
                if (resC instanceof Double) {
                    double timeC = (Double) resC;
                    resultsC.add(timeC);
                } else
                    Assertions.fail("Unexpected return value: " + resC.getClass());
            }
            saveMeasurements(resultsJava, resultsC);
        } catch (ClassNotFoundException | IOException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
            Assertions.fail(e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Return the path to the output CSV (Including its name)
     *
     * @return The path to the output CSV that will contain the measurements, generated by the test
     */
    public String getReportFileName() {
        return "build/reports/tests/performance/" + getClassName() + ".csv";
    }

    /**
     * Function that will be called after all the repetitions and saves all the time values collected into
     * getReportFileName()
     *
     * @param resultsJava the time required to run the pattern() of every repetition, in nanoseconds, ran on the Java layer
     * @param resultsC    the time required to run the pattern() of every repetition, in nanoseconds, ran on the C layer
     */
    public void saveMeasurements(ArrayList<Double> resultsJava, ArrayList<Double> resultsC) {
        File f = new File(getReportFileName());
        f.getParentFile().mkdirs();
        assert (resultsJava.size() == resultsC.size());
        try {
            FileOutputStream fout = new FileOutputStream(f);
            PrintWriter pw = new PrintWriter(fout);
            pw.println("TimeJava(ns),TimeC(ns)");
            for (int i = 0; i < resultsJava.size(); i++) {
                pw.println(resultsJava.get(i) + "," + resultsC.get(i));
            }
            pw.close();
        } catch (IOException ignored) {
        }
    }

    /**
     * Returns the directory where the crafted file executed in Java will be stored
     *
     * @return the directory for the plain java file
     */
    public String getJavaPerformanceDir() {
        return getDestDir() + File.separator + "performance-java";
    }

    /**
     * Returns the directory where the crafted file executed in C will be stored
     *
     * @return the directory for the plain java file
     */
    public String getCPerformanceDir() {
        return getDestDir() + File.separator + "performance-c";
    }

    /**
     * Returns the number of repetition of the pattern, in the actual Java code
     *
     * @return how many times the pattern should be repeated in the emitted code in order
     */
    public int patternRepetitions() {
        return 10000;
    }

    /**
     * Returns the number of executions performed, in order to get a better statistical representation
     *
     * @return The number of executions of the performance measurements, without the compilation
     */
    public int executionRepetitions() {
        return 1000;
    }

    /**
     * How many opcodes are left uncleaned on the stack after every pattern repetition.
     * This is used to craft the correct stack size with the formula pollution*repetitions
     *
     * @return The number of garbage left uncleaned onto the stack after every repetition
     */
    public int stackPollution() {
        return 0;
    }

    /**
     * Returns the name of the class that will be emitted. This should be the simple name
     *
     * @return the name of the class that will be emitted
     */
    public abstract String getClassName();

    /**
     * The pattern that will be evaluated. This pattern is emitted patternRepetitions() times.
     * This should be implemented by calling the various visitInsn with the MethodVisitor received as parameter
     *
     * @param mv The MethodVisitor that will visit the various instructions
     */
    public abstract void pattern(MethodVisitor mv);

    /**
     * Opcodes that will be emitted before the actual pattern. Like a sort of initialization. These opcodes will not
     * be evaluated in term of time.
     * This should be implemented by calling the various visitInsn with the MethodVisitor received as parameter
     *
     * @param mv The MethodVisitor that will visit the various instructions
     */
    public void beforePattern(final @NotNull MethodVisitor mv) {
    }

    private void emitter(boolean profiledByJava) throws IOException {

        String className = (this.getClass().getPackage().getName() + File.separator + getClassName()).replaceAll("\\.", "/");
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER, className, null, "java/lang/Object", null);
        cw.visitSource(className.substring(className.lastIndexOf(".") + 1), null);

        //generate constructor
        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
        mv.visitCode();
        Label label0 = new Label();
        mv.visitLabel(label0);
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        mv.visitInsn(Opcodes.RETURN);
        Label label1 = new Label();
        mv.visitLabel(label1);
        mv.visitLocalVariable("this", "L" + className + ";", null, label0, label1, 0);
        mv.visitEnd();

        //generate tested method
        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "test", "()D", null, null);
        //generate annotation
        AnnotationVisitor av = mv.visitAnnotation("L" + Obfuscation.class.getName().replace('.', '/') + ";", true);
        av.visitEnum("protections", "L" + Protections.class.getName().replaceAll("\\.", "/") + ";", Protections.TO_NATIVE_CODE.toString());
        av.visitEnd();

        mv.visitCode();
        Label labelStart = new Label();
        mv.visitLabel(labelStart);
        beforePattern(mv);
        //start profilation
        if (profiledByJava) {
            System.nanoTime();
            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
            mv.visitVarInsn(Opcodes.LSTORE, 8);
        } else {
            mv.visitInsn(Opcodes.NOP); // in the C code the first NOP is replaced by the timer
        }

        for (int i = 0; i < patternRepetitions(); i++) {
            pattern(mv);
        }

        if (profiledByJava) {
            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
            mv.visitIntInsn(Opcodes.LLOAD, 8);
            mv.visitInsn(Opcodes.LSUB);
            mv.visitInsn(Opcodes.L2D);
        } else {
            mv.visitInsn(Opcodes.NOP); //second NOP, end profilation
        }

        mv.visitInsn(Opcodes.DRETURN);
        Label labelEnd = new Label();
        mv.visitLabel(labelEnd);
        mv.visitLocalVariable("this", "L" + className + ";", null, labelStart, labelEnd, 0);
        mv.visitEnd();
        mv.visitMaxs(10 + stackPollution() * patternRepetitions(), 10);
        cw.visitEnd();

        File f;
        if (profiledByJava) {
            f = new File(getJavaPerformanceDir() + File.separator + className + ".class");
        } else {
            f = new File(getCPerformanceDir() + File.separator + className + ".class");
        }
        f.getParentFile().mkdirs();
        FileOutputStream outputClass = new FileOutputStream(f);
        outputClass.write(cw.toByteArray());
        outputClass.close();
    }

    /**
     * Replace the various NOP instructions generated by the emitter() with profilation instructions
     *
     * @param libname The name of the library that will be outputted
     * @throws IOException if the .c file can not be found
     */
    private void profileFile(String libname) throws IOException {
        Path path = Paths.get(OUTPUT_LIB_DIR + File.separator + libname + ".c");
        Charset charset = StandardCharsets.US_ASCII;

        String content = new String(Files.readAllBytes(path), charset)
                .replaceFirst("#define NOP", "#include <time.h>")
                .replaceFirst("NOP;", "struct timespec time0;\nstruct timespec time1;\nclock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time0);")
                .replaceFirst("NOP;", "clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time1);\npop2(_stack,&_index);\npushd(_stack,&_index,diff(time0,time1).tv_nsec);");
        Files.write(path, content.getBytes(charset));
    }

    @Override
    public Class<?> getTestClass() {
        return null;
    }

    @Override
    public String[] getTestMethodName() {
        return new String[]{"test"};
    }

    @Override
    public Class<?>[][] getTestMethodParams() {
        return new Class[][]{new Class[0]};
    }

    @Override
    public Object[][] getTestMethodArgs() {
        return new Object[][]{new Object[0]};
    }
}

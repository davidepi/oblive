# Oblive

![ci badge](https://github.com/davidepi/oblive/actions/workflows/ci/badge.svg)

Oblive is an hardening tool that enables C obfuscations and antidebugging in languages running on the Java Virtual Machine (e.g. Java, Kotlin, ...).
Protections are performed automatically, with the user having only to signal, with an annotation, which part of the code to protect.

**DISCLAIMER**: This project is purely academic and does not meet the engineering standards required for a safe production usage.
Please do **NOT** use this code in production.

## Usage

The package `it.oblive.annotations` contains the Annotations that should be used to specify methods to be protected.
The annotations are the following:
- `@Native`: methods with this annotation are removed from their respective `.class` file and replaced with a semantically equivalent C implementation.
- `@AntidebugTime`: methods with this annotation implement time check debugging and backend damaging. This is a trivial type of antidebugging with very low resilience.
- `@AntidebugSelf`: methods with this annotation implement self-debugging and backend damaging. The self debugging implemented by this annotation is currently state-of-the-art antidebugging, albeit with a heavy execution time cost.

Usage:
```bash
java -jar oblive.jar <input_file>.jar <output_file>.jar
```
where `<input_file>.jar` is the jar containing the annotated methods that will be protected, and `<output_file>.jar` is the results of the operation. This will likely generate additional files such as a `.so` library that must be placed in the `java.library.path` during execution and an executable that must be in the PATH, if the antidebug was requested.

Note that *libcrypto* is required to be installed in the system when applying the `@AntidebugSelf` protection.

## Protections

Brief description of all the protections that can be applied.

### Native translation (Java2C)
The `@Native` annotation uses the *Java2C* tool, contained in this repository, to translate a Java bytecode method into a C method.
The steps performed are the following:
- The body of a method with the `@Native` keyword is removed from the original Java bytecode
- The method signature is changed to `native`, indicating that the method implementation can be found in a native library
- The removed body is parsed instruction by instruction, each JVM opcode is replaced [by a C implementation](java2c/src/main/resources) [inside a JNI method](java2c/src/main/java/it/oblive/CSourceGenerator.java)
- The static init method of the original class containing the annotated method is modified, so the class can load the compiled C implementation at runtime

More information can be found in the paper
> Obfuscating Java Programs by Translating Selected Portions of Bytecode to Native Libraries
>
> D. Pizzolotto, M. Ceccato
>

### Self-debugging
The self-debugging protection is very complex, and only the major key points are
listed in this README.

The protection works in the following way:
- The protected method is translated to C using *Java2C*.
- An additional VM called OVM is spawned and debugs the JNI. The JNI, in turn, debugs the OVM.
- To prevent an attacker from killing the OVM, the C implementation of some JVM opcodes can be found only in the OVM. When the JNI translation of the method requires one of these opcodes, it needs to ask the OVM to perform the computation.
- JNI and OVM communication is encrypted using OTP. The OTP is generated by a PRNG seeded equally by both JNI and OVM. This is done solely to make the `ptrace` mandatory. In fact, the seed of the PRNG is generated half on the JNI and half on the OVM, then exchanged using the `ptrace` call. For this reason an attacker can not replace the `ptrace` with `NOOP` (and thus enable debugging) otherwise JNI and OVM will miscommunicate.
- To prevent an attacker from performing Man-in-the-Middle attacks between JNI and OVM, the two processes are authenticated using an AES key generated at compile time.

More information can be found in the paper
> Mitigating Debugger-based Attacks to Java Applications with Self-Debugging
>
> D. Pizzolotto, S. Berlato, M. Ceccato
>

### Backend damaging

This protection is applied when any antidebugging is requested. The purpose of this protection is to prevent an attacker 
from circumventing the antidebugging protection with a blackbox analysis and input/output manipulation of the protected method.
In order to do so, the backend damaging messes up with the Java Debug Wire Protocol (JDWP), used to debug JVM programs, and destroys the debugging capabilities of the Java Platform Debugger Architecture (JPDA).

## Repo Structure

The project is composed by the following elements:
- [annotations](annotations): contains the annotation that should be used by the user to signal which methods to protect.
- [java2c](java2c): contains the *Java2C* program, resposible of applying the `@Native` and `@AntidebugSelf` protections to `.class` files.
- [oblive](oblive): contains the *Oblive* program, responsible of unpacking an input `.jar`, calling *Java2C* for all the `.class` files, packing the output `.class` into a `.jar` and compiling the generated files.

## Authors

- [Davide Pizzolotto](https://github.com/davidepi) - Java2C and Self-debug protection
- [Stefano Berlato](https://github.com/StefanoBerlato) - JDWP manipulation and backend damaging
- [Luca Gasparetto](https://github.com/LucaGaspa) - Moral supporter for Java2C
- Mariano Ceccato - Supervisor
